# ğŸ“š JavaScript Lanjutan: Execution Context, Hoisting & Scope

> **Dokumentasi Pribadi untuk Pemula** ğŸš€  
> Memahami konsep unik JavaScript yang menjadi dasar untuk memahami Closures

---

## ğŸ“‘ Daftar Isi

- [Pengenalan](#pengenalan)
- [Apa itu Execution Context?](#apa-itu-execution-context)
  - [Creation Phase](#creation-phase)
  - [Execution Phase](#execution-phase)
- [Apa itu Hoisting?](#apa-itu-hoisting)
  - [Hoisting pada Variabel (var)](#hoisting-pada-variabel)
  - [Hoisting pada Function](#hoisting-pada-function)
  - [Perbedaan var, let, dan const](#perbedaan-var-let-const)
- [Global vs Local Execution Context](#global-vs-local-execution-context)
- [Apa itu Scope?](#apa-itu-scope)
- [Execution Stack](#execution-stack)
- [Object Arguments](#object-arguments)
- [Latihan dan Studi Kasus](#latihan-dan-studi-kasus)
- [Tool Visualisasi](#tool-visualisasi)
- [Kesimpulan](#kesimpulan)

---

<a name="pengenalan"></a>
## ğŸ¯ Pengenalan

JavaScript memiliki cara kerja yang **unik** dan kadang **terlihat aneh** dibanding bahasa pemrograman lain. Tiga konsep penting yang harus dipahami adalah:

1. âš™ï¸ **Execution Context** - Konteks eksekusi program
2. ğŸ£ **Hoisting** - Pengangkatan variabel/function ke atas
3. ğŸ” **Scope** - Jangkauan akses variabel

> âš ï¸ **Penting:** Konsep ini adalah fondasi untuk memahami **Closures** di JavaScript!

---

<a name="apa-itu-execution-context"></a>
## ğŸ“– Apa itu Execution Context?

**Execution Context** adalah lingkungan di mana kode JavaScript dijalankan. Setiap kali program berjalan, JavaScript membuat konteks eksekusi yang memiliki **2 fase**:

<a name="creation-phase"></a>
### 1ï¸âƒ£ Creation Phase (Fase Pembentukan)

Pada fase ini, JavaScript melakukan persiapan **SEBELUM** kode dijalankan:

âœ… Membuat object `window` sebagai **global object**  
âœ… Membuat `this` yang merujuk ke `window`  
âœ… Mengecek semua **variabel** dan mengisinya dengan `undefined`  
âœ… Mengecek semua **function** dan menyimpan kode function-nya

```javascript
// Contoh 1: Variabel sebelum dideklarasikan
console.log(nama); // Output: undefined (bukan error!)

var nama = 'Budi';
```

**ğŸ’¡ Penjelasan:**
- Meskipun `nama` belum didefinisikan saat `console.log()`, tidak terjadi error
- Karena di **Creation Phase**, JavaScript sudah membuat variabel `nama` dengan nilai `undefined`

<a name="execution-phase"></a>
### 2ï¸âƒ£ Execution Phase (Fase Eksekusi)

Setelah Creation Phase selesai, JavaScript menjalankan kode **baris per baris** dari atas ke bawah:

```javascript
console.log(nama); // undefined (dari Creation Phase)
var nama = 'Budi';
console.log(nama); // Budi (dari Execution Phase)
```

**ğŸ”„ Alur Lengkap:**
1. **Creation Phase**: `nama = undefined`
2. **Execution Phase**: 
   - Baris 1: `console.log(nama)` â†’ `undefined`
   - Baris 2: `nama = 'Budi'`
   - Baris 3: `console.log(nama)` â†’ `Budi`

---

<a name="apa-itu-hoisting"></a>
## ğŸ£ Apa itu Hoisting?

**Hoisting** = proses "mengangkat" (seperti mengerek bendera) deklarasi variabel dan function ke **atas scope** saat Creation Phase.

<a name="hoisting-pada-variabel"></a>
### ğŸ“¦ Hoisting pada Variabel (var)

```javascript
// Kode yang kita tulis:
console.log(nama); // undefined
var nama = 'Andi';

// Yang terjadi di balik layar (konsep):
var nama; // dideklarasikan dulu (hoisting)
console.log(nama); // undefined
nama = 'Andi'; // baru diisi nilainya
```

**âš ï¸ Penting:** Hanya **deklarasi** yang di-hoist, bukan **nilainya**!

<a name="hoisting-pada-function"></a>
### ğŸ”§ Hoisting pada Function

```javascript
// Function bisa dipanggil sebelum dideklarasikan!
console.log(sayHello()); // Output: "Halo, nama saya undefined, saya undefined tahun."

var nama = 'Rina';
var umur = 25;

function sayHello() {
  return `Halo, nama saya ${nama}, saya ${umur} tahun.`;
}
```

**ğŸ’¡ Penjelasan:**
- Function di-hoist dengan **seluruh isinya**, jadi bisa dipanggil duluan
- **TAPI** variabel `nama` dan `umur` belum diisi nilainya (masih `undefined`)
- Makanya outputnya: `"Halo, nama saya undefined, saya undefined tahun."`

**âœ… Contoh yang Benar:**

```javascript
var nama = 'Rina';
var umur = 25;

console.log(sayHello()); // Output: "Halo, nama saya Rina, saya 25 tahun."

function sayHello() {
  return `Halo, nama saya ${nama}, saya ${umur} tahun.`;
}
```

**ğŸ’¡ Penjelasan:**
- Variabel `nama` dan `umur` sudah diisi nilai SEBELUM function dipanggil
- Jadi outputnya benar: `"Halo, nama saya Rina, saya 25 tahun."`

---

<a name="perbedaan-var-let-const"></a>
### ğŸ†š Perbedaan var, let, dan const dalam Hoisting

#### 1ï¸âƒ£ **VAR** - Di-hoist dengan nilai `undefined`

```javascript
console.log(nama); // undefined
var nama = 'Budi';
```

**ğŸ’¡ Penjelasan:**
- `var` di-hoist dan diisi `undefined`
- Tidak error, tapi nilainya `undefined`

---

#### 2ï¸âƒ£ **LET** - Di-hoist tapi masuk Temporal Dead Zone

```javascript
console.log(nama); // âŒ ReferenceError: Cannot access 'nama' before initialization
let nama = 'Budi';
```

**ğŸ’¡ Penjelasan:**
- `let` **TETAP di-hoist**, tapi tidak diisi `undefined`
- Masuk **Temporal Dead Zone (TDZ)** - zona terlarang
- Tidak bisa diakses sebelum deklarasi â†’ Error!

---

#### 3ï¸âƒ£ **CONST** - Di-hoist tapi masuk Temporal Dead Zone

```javascript
console.log(nama); // âŒ ReferenceError: Cannot access 'nama' before initialization
const nama = 'Budi';
```

**ğŸ’¡ Penjelasan:**
- `const` juga di-hoist dan masuk **Temporal Dead Zone**
- Tidak bisa diakses sebelum deklarasi â†’ Error!
- `const` harus langsung diisi nilai saat deklarasi

---

#### ğŸ“Š Tabel Perbandingan Hoisting

| Fitur | var | let | const |
|-------|-----|-----|-------|
| **Di-hoist?** | âœ… Ya | âœ… Ya | âœ… Ya |
| **Nilai awal** | `undefined` | âŒ TDZ | âŒ TDZ |
| **Akses sebelum deklarasi** | âœ… Bisa (undefined) | âŒ Error | âŒ Error |
| **Bisa diubah?** | âœ… Ya | âœ… Ya | âŒ Tidak |

---

#### ğŸ¯ Contoh Lengkap Perbandingan

```javascript
// ===== VAR =====
console.log(namaVar); // undefined
var namaVar = 'Budi';
console.log(namaVar); // Budi

// ===== LET =====
console.log(namaLet); // âŒ ReferenceError
let namaLet = 'Andi';
console.log(namaLet); // Andi

// ===== CONST =====
console.log(namaConst); // âŒ ReferenceError
const namaConst = 'Siti';
console.log(namaConst); // Siti
```

**ğŸ“ Rekomendasi Best Practice:**
- ğŸš« Hindari `var` di kode modern
- âœ… Gunakan `let` untuk variabel yang nilainya berubah
- âœ… Gunakan `const` untuk variabel yang nilainya tetap (default choice)

---

<a name="global-vs-local-execution-context"></a>
## ğŸŒ Global vs Local Execution Context

### ğŸŒ Global Execution Context

Dibuat untuk kode yang **tidak berada di dalam function**:

```javascript
var nama = 'Doni'; // Global
var username = '@doni123'; // Global

console.log(window); // Object window ada
console.log(this); // Merujuk ke window
```

**Yang tersedia:**
- âœ… `window` object
- âœ… `this` (= window)
- âœ… Hoisting untuk variabel & function

### ğŸ“ Local Execution Context

Dibuat **setiap kali function dipanggil**:

```javascript
var nama = 'Rudi';
var username = '@rudi456';

function cetakURL(username) {
  // Local Execution Context dimulai di sini
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username;
}

console.log(cetakURL(username)); 
// Output: http://instagram.com/@rudi456
```

**Yang tersedia:**
- âœ… `window` object (masih bisa diakses)
- âœ… `arguments` object (khusus function)
- âœ… Hoisting lokal untuk variabel & function di dalam function
- âœ… Parameter function

**ğŸ”„ Proses yang terjadi:**
1. **Creation Phase** di dalam function:
   - Parameter `username` siap menerima nilai
   - Variabel `instagramURL` di-set `undefined`
2. **Execution Phase**:
   - `instagramURL` diisi dengan `'http://instagram.com/'`
   - Return hasil penggabungan

---

<a name="apa-itu-scope"></a>
## ğŸ” Apa itu Scope?

**Scope** = jangkauan/area di mana variabel bisa diakses.

### ğŸ“‹ Aturan Pencarian Variabel

JavaScript mencari variabel dengan urutan:
1. ğŸ” **Lokal** (dalam function saat ini)
2. ğŸ” **Parameter** function
3. ğŸ” **Global** (di luar function)
4. âŒ Jika tidak ketemu â†’ **ReferenceError**

### ğŸ’¼ Contoh Kasus Scope

```javascript
var nama = 'Rudi'; // Global
var username = '@rudi456'; // Global

function cetakURL(username) { // Parameter: username
  var instagramURL = 'http://instagram.com/'; // Lokal
  return instagramURL + username; // Pakai parameter, bukan global!
}

console.log(cetakURL('@agus789')); 
// Output: http://instagram.com/@agus789
```

**ğŸ’¡ Analisis:**
- `username` di dalam function **menggunakan parameter**, bukan variabel global
- Parameter lebih "dekat" dengan scope function

### ğŸ”„ Contoh Tanpa Parameter

```javascript
var nama = 'Rudi';
var username = '@rudi456';

function cetakURL() { // Tanpa parameter
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username; // Cari di global
}

console.log(cetakURL()); 
// Output: http://instagram.com/@rudi456
```

**ğŸ’¡ Analisis:**
- Function tidak punya parameter `username`
- Tidak ada variabel lokal `username`
- JavaScript naik ke scope global dan menemukan `username`

---

### âš ï¸ Contoh Kasus: ReferenceError

```javascript
function cetakURL() {
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username; // âŒ username tidak ada!
}

console.log(cetakURL('@agus789', '@budi123'));
// Output: âŒ ReferenceError: username is not defined
```

**ğŸ’¡ Analisis:**
1. Function `cetakURL()` tidak punya **parameter**
2. Di dalam function tidak ada **variabel lokal** `username`
3. Di **global scope** juga tidak ada variabel `username`
4. JavaScript mencari di semua scope â†’ **tidak ketemu**
5. Hasil: **ReferenceError** âŒ

**ğŸ” Kenapa argumen `@agus789` dan `@budi123` tidak terpakai?**
- Argumen memang dikirim dan masuk ke `arguments` object
- Tapi karena tidak ada parameter yang menangkap
- Dan di dalam function memanggil variabel `username` yang tidak ada
- Maka terjadi error sebelum sempat menggunakan `arguments`

**âœ… Solusi 1: Tambahkan Parameter**
```javascript
function cetakURL(username) { // Ada parameter
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username;
}

console.log(cetakURL('@agus789'));
// Output: http://instagram.com/@agus789
```

**âœ… Solusi 2: Buat Variabel Global**
```javascript
var username = '@default123'; // Global

function cetakURL() {
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username; // Ambil dari global
}

console.log(cetakURL());
// Output: http://instagram.com/@default123
```

**âœ… Solusi 3: Gunakan Arguments Object**
```javascript
function cetakURL() {
  var instagramURL = 'http://instagram.com/';
  return instagramURL + arguments[0]; // Ambil argumen pertama
}

console.log(cetakURL('@agus789', '@budi123'));
// Output: http://instagram.com/@agus789
```

---

<a name="execution-stack"></a>
## ğŸ“š Execution Stack (Tumpukan Eksekusi)

**Execution Stack** = tumpukan konteks eksekusi yang sedang berjalan.

### ğŸ¯ Konsep Stack

```javascript
function a() {
  console.log('ini a');
  
  function b() {
    console.log('ini b');
    
    function c() {
      console.log('ini c');
    }
    c(); // Panggil c
  }
  b(); // Panggil b
}

a(); // Panggil a
```

**ğŸ”„ Urutan Eksekusi:**

```
Output:
ini a
ini b
ini c
```

**ğŸ“Š Stack Process:**

1. **Global Context** dimuat
2. Function `a()` dipanggil â†’ Stack: `[Global, a]`
3. Function `b()` dipanggil â†’ Stack: `[Global, a, b]`
4. Function `c()` dipanggil â†’ Stack: `[Global, a, b, c]`
5. `c()` selesai â†’ Stack: `[Global, a, b]`
6. `b()` selesai â†’ Stack: `[Global, a]`
7. `a()` selesai â†’ Stack: `[Global]`

> ğŸ¯ **Prinsip LIFO** (Last In First Out): Function yang terakhir dipanggil, selesai duluan!

---

<a name="object-arguments"></a>
## ğŸ“¦ Object Arguments

Setiap function memiliki **object `arguments`** yang menyimpan semua argumen yang dikirimkan.

### ğŸ” Contoh Penggunaan

```javascript
function cetakURL() {
  console.log(arguments); // Object berisi semua argumen
  console.log(arguments[0]); // Argumen pertama
  console.log(arguments[1]); // Argumen kedua
}

cetakURL('@agus789', '@budi123');
```

**ğŸ“¤ Output:**
```
Arguments(2) ['@agus789', '@budi123']
@agus789
@budi123
```

**ğŸ’¡ Kegunaan:**
- Menangkap argumen meskipun tidak ada parameter
- Mengakses argumen dengan index seperti array
- Berguna untuk function dengan jumlah argumen dinamis

---

<a name="latihan-dan-studi-kasus"></a>
## ğŸ“ Latihan dan Studi Kasus

### ğŸ§© Studi Kasus 1: Hoisting Variabel

```javascript
console.log(nama); // Output: undefined (bukan error!)
var nama = 'Budi';
```

**ğŸ” Mengapa `undefined`?**
- Creation Phase: `nama` dibuat dengan nilai `undefined`
- Execution Phase: `console.log(nama)` â†’ `undefined`
- Lalu `nama` diisi `'Budi'`

---

### ğŸ§© Studi Kasus 2: Hoisting Function dengan Variabel

```javascript
// âŒ CONTOH YANG SALAH URUTAN
console.log(sayHello()); // "Halo, nama saya undefined, saya undefined tahun."

var nama = 'Rina';
var umur = 25;

function sayHello() {
  return `Halo, nama saya ${nama}, saya ${umur} tahun.`;
}
```

**ğŸ” Mengapa output-nya `undefined`?**
1. **Creation Phase:**
   - Function `sayHello` di-hoist â†’ tersimpan lengkap
   - Variabel `nama` di-hoist â†’ nilai `undefined`
   - Variabel `umur` di-hoist â†’ nilai `undefined`

2. **Execution Phase:**
   - Baris 1: `console.log(sayHello())` â†’ function dipanggil
   - Di dalam function, `nama` masih `undefined`
   - Di dalam function, `umur` masih `undefined`
   - Output: `"Halo, nama saya undefined, saya undefined tahun."`
   - Baris 2-3: Baru `nama` dan `umur` diisi nilai

**âœ… CONTOH YANG BENAR:**
```javascript
var nama = 'Rina';
var umur = 25;

console.log(sayHello()); // "Halo, nama saya Rina, saya 25 tahun."

function sayHello() {
  return `Halo, nama saya ${nama}, saya ${umur} tahun.`;
}
```

**ğŸ” Mengapa sekarang benar?**
- Variabel `nama` dan `umur` sudah diisi SEBELUM function dipanggil
- Saat function dijalankan, `nama` = `'Rina'` dan `umur` = `25`

---

### ğŸ§© Studi Kasus 3: Hoisting dengan let/const

```javascript
// ===== DENGAN VAR =====
console.log(namaVar); // undefined âœ…
var namaVar = 'Budi';

// ===== DENGAN LET =====
console.log(namaLet); // âŒ ReferenceError
let namaLet = 'Andi';

// ===== DENGAN CONST =====
console.log(namaConst); // âŒ ReferenceError
const namaConst = 'Siti';
```

**ğŸ’¡ Analisis:**
- `var`: Di-hoist dengan nilai `undefined`, bisa diakses (tapi nilainya `undefined`)
- `let` & `const`: Di-hoist tapi masuk **Temporal Dead Zone**, tidak bisa diakses â†’ Error!

---

### ğŸ§© Studi Kasus 4: Scope Priority

```javascript
function satu() {
  var nama = 'Dewi'; // Lokal
  console.log(nama); // Dewi
}

function dua() {
  console.log(nama); // Andi (dari global)
}

console.log(nama); // undefined (Creation Phase)
var nama = 'Andi'; // Global
satu(); // Dewi
dua('Rudi'); // Andi
console.log(nama); // Andi
```

**ğŸ“Š Analisis Lengkap:**

1. **`console.log(nama)`** (baris 1):
   - Creation Phase sudah membuat `nama = undefined`
   - Output: `undefined`

2. **`var nama = 'Andi'`** (baris 2):
   - Variabel global `nama` diisi `'Andi'`

3. **`satu()`** (baris 3):
   - Masuk Local Execution Context
   - Hoisting lokal: `nama = undefined`
   - Execution: `nama = 'Dewi'`
   - Output: `Dewi`
   - Context selesai, variabel lokal dihapus dari memory

4. **`dua('Rudi')`** (baris 4):
   - Masuk Local Execution Context
   - Parameter `'Rudi'` masuk ke `arguments[0]`
   - Cari variabel `nama`: tidak ada lokal â†’ cek global
   - Output: `Andi` (dari global)

5. **`console.log(nama)`** (baris 5):
   - Output: `Andi` (variabel global)

---

### ğŸ§© Studi Kasus 5: Arguments Object

```javascript
function cetakURL() {
  console.log(arguments);
  var instagramURL = 'http://instagram.com/';
  return instagramURL + arguments[0];
}

console.log(cetakURL('@agus789', '@budi123'));
```

**ğŸ“¤ Output:**
```
Arguments(2) ['@agus789', '@budi123']
http://instagram.com/@agus789
```

**ğŸ’¡ Penjelasan:**
- Meskipun function tidak punya parameter
- Argumen tetap masuk ke `arguments` object
- Bisa diakses dengan index: `arguments[0]`, `arguments[1]`, dst

---

### ğŸ§© Studi Kasus 6: ReferenceError

```javascript
function cetakURL() {
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username; // âŒ username tidak ada!
}

console.log(cetakURL('@agus789', '@budi123'));
// Output: âŒ ReferenceError: username is not defined
```

**ğŸ’¡ Penjelasan:**
- Function tidak punya parameter `username`
- Tidak ada variabel lokal `username`
- Tidak ada variabel global `username`
- JavaScript mencari di semua scope â†’ tidak ketemu
- Hasil: **ReferenceError** âŒ

---

<a name="tool-visualisasi"></a>
## ğŸ› ï¸ Tool Visualisasi

### ğŸŒ JavaScript Visualizer

Untuk memahami execution context lebih baik, gunakan:

**ğŸ”— Link:** [Python Tutor - JavaScript Visualizer](https://pythontutor.com/javascript.html)

**ğŸ“‹ Cara Menggunakan:**
1. Kunjungi website
2. Paste kode JavaScript
3. Klik tombol **"Visualize Execution"**
4. Gunakan tombol **"Forward"** untuk melihat step-by-step

**ğŸ¯ Manfaat:**
- Melihat Creation Phase dan Execution Phase
- Memahami Hoisting secara visual
- Melihat Execution Stack terbentuk
- Tracking nilai variabel di memory

---

<a name="kesimpulan"></a>
## âœ… Kesimpulan

### ğŸ“Œ Poin-Poin Penting

1. **âš™ï¸ Execution Context:**
   - Setiap program punya Global Execution Context
   - Setiap function punya Local Execution Context
   - Terdiri dari Creation Phase dan Execution Phase

2. **ğŸ£ Hoisting:**
   - **var**: Di-hoist dengan nilai `undefined`
   - **let & const**: Di-hoist tapi masuk Temporal Dead Zone â†’ Error jika diakses sebelum deklarasi
   - **Function**: Di-hoist dengan seluruh kodenya
   - Hanya deklarasi yang di-hoist, bukan nilainya

3. **ğŸ” Scope:**
   - Pencarian variabel: Lokal â†’ Parameter â†’ Global
   - Jika tidak ketemu sama sekali â†’ ReferenceError
   - Local scope tidak bisa diakses dari luar

4. **ğŸ“š Execution Stack:**
   - Prinsip LIFO (Last In First Out)
   - Function yang dipanggil masuk ke stack
   - Setelah selesai, keluar dari stack

5. **ğŸ“¦ Arguments Object:**
   - Tersedia di setiap function
   - Menampung semua argumen yang dikirim
   - Bisa diakses meskipun tidak ada parameter

---

### ğŸ¯ Next Step

Konsep-konsep ini adalah **fondasi** untuk memahami:
- âœ¨ **Closures** (topik selanjutnya)
- ğŸ”„ **Arrow Functions**
- âš¡ **Asynchronous JavaScript**
- ğŸª **Event Loop**

---

### ğŸ“š Referensi Kode Lengkap

```javascript
// =====================================
// EXECUTION CONTEXT, HOISTING & SCOPE
// =====================================

// --- Contoh 1: Hoisting Variabel (var) ---
console.log(nama); // undefined
var nama = 'Budi';
console.log(nama); // Budi

// --- Contoh 2: Hoisting dengan let ---
console.log(namaLet); // âŒ ReferenceError
let namaLet = 'Andi';

// --- Contoh 3: Hoisting dengan const ---
console.log(namaConst); // âŒ ReferenceError
const namaConst = 'Siti';

// --- Contoh 4: Hoisting Function (Urutan Salah) ---
console.log(sayHello()); // "Halo, nama saya undefined, saya undefined tahun."

var nama = 'Rina';
var umur = 25;

function sayHello() {
  return `Halo, nama saya ${nama}, saya ${umur} tahun.`;
}

// --- Contoh 5: Hoisting Function (Urutan Benar) ---
var nama = 'Rina';
var umur = 25;

console.log(sayHello()); // "Halo, nama saya Rina, saya 25 tahun."

function sayHello() {
  return `Halo, nama saya ${nama}, saya ${umur} tahun.`;
}

// --- Contoh 6: Local Execution Context ---
var nama = 'Doni';
var username = '@doni123';

function cetakURL(username) {
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username;
}

console.log(cetakURL(username));

// --- Contoh 7: Execution Stack ---
function a() {
  console.log('ini a');
  
  function b() {
    console.log('ini b');
    
    function c() {
      console.log('ini c');
    }
    c();
  }
  b();
}

a();

// --- Contoh 8: Arguments Object ---
function cetakURL() {
  console.log(arguments);
  console.log(arguments[0]);
  var instagramURL = 'http://instagram.com/';
  return instagramURL + arguments[0];
}

console.log(cetakURL('@agus789', '@budi123'));

// --- Contoh 9: ReferenceError ---
function cetakURL() {
  var instagramURL = 'http://instagram.com/';
  return instagramURL + username; // âŒ Error!
}

console.log(cetakURL('@agus789', '@budi123'));

// --- Contoh 10: Scope Priority ---
function satu() {
  var nama = 'Dewi';
  console.log(nama);
}

function dua() {
  console.log(nama);
}

console.log(nama); // undefined
var nama = 'Andi';
satu(); // Dewi
dua('Rudi'); // Andi
console.log(nama); // Andi
```

---

> ğŸ’¡ **Tips Belajar:**  
> - Jangan ragu untuk mengulang video berkali-kali
> - Coba semua contoh kode sendiri
> - Gunakan JavaScript Visualizer untuk pemahaman lebih dalam
> - Gunakan `let` dan `const` di kode modern, hindari `var`
> - Practice makes perfect! ğŸš€

---

**ğŸ“ Catatan Pribadi:**  
Dokumentasi ini dibuat untuk membantu pemahaman konsep JavaScript yang unik. Jika masih bingung, tidak masalah! Konsep ini butuh waktu untuk dipahami. Keep learning! ğŸ’ª

---

**ğŸ“ Sumber Materi:**  
Web Programming Unpas - JavaScript Lanjutan  
Instructor: Sandhika Galih

---

<div align="center">
  
**âœ¨ Selamat Belajar! âœ¨**

**Jangan lupa titik koma!** ğŸ˜Š

</div>
