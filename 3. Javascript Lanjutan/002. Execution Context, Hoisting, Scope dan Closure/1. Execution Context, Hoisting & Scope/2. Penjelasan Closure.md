# ğŸ” JavaScript Closure & Lexical Scope

> **Tingkat Kesulitan:** ![Menengah](https://img.shields.io/badge/Level-Menengah-orange) ![JavaScript](https://img.shields.io/badge/JavaScript-ES6-yellow)

## ğŸ“ Apa itu Closure?

**Closure** adalah salah satu konsep penting dalam JavaScript yang sering membingungkan pemula. Mari kita pahami dengan definisi sederhana:

> ğŸ” **Closure** adalah sebuah function yang memiliki akses ke variabel dari function parent-nya, bahkan setelah function parent tersebut selesai dijalankan.

### ğŸ”¬ Beberapa Definisi Closure:

| Sumber | Definisi |
|--------|----------|
| **MDN** | Kombinasi antara function dan lingkungan lexical di dalam function tersebut |
| **W3Schools** | Function yang memiliki akses ke parent scope-nya, meskipun parent scope sudah selesai dieksekusi |
| **Code Follow** | Function yang dikembalikan oleh function lain, yang memiliki akses ke lingkungan saat ia diciptakan |

---

## ğŸŒ Lexical Scope

Sebelum memahami closure, kita perlu tahu tentang **Lexical Scope**:

> ğŸ” **Lexical Scope** adalah aturan dimana inner function (function di dalam) memiliki akses ke variabel dari outer function (function di luar).

### ğŸ—ï¸ Struktur Lexical Scope

```
Global Scope
â”œâ”€â”€ Function A Scope
â”‚   â”œâ”€â”€ Variable A
â”‚   â””â”€â”€ Function B Scope
â”‚       â”œâ”€â”€ Variable B
â”‚       â””â”€â”€ Function C Scope
â”‚           â””â”€â”€ Variable C
```

### ğŸ“‹ Contoh Dasar Lexical Scope:

```javascript
function init() {
  let nama = 'ahmad'; // local variable di outer function

  function tampilNama() {
    // inner function bisa akses variabel outer function
    console.log(nama); // mengakses variabel 'nama' dari parent
  }

  tampilNama();
}

init(); // Output: "ahmad"
```

### ğŸ” Penjelasan Detail:

1. **Outer Function** (`init`) memiliki variabel `nama`
2. **Inner Function** (`tampilNama`) bisa mengakses variabel `nama` 
3. Ini terjadi karena JavaScript menggunakan **Lexical Scoping**

### ğŸ¯ Contoh Lebih Kompleks:

```javascript
let globalVar = 'Global'; // Global scope

function outerFunction() {
  let outerVar = 'Outer'; // Outer function scope
  
  function middleFunction() {
    let middleVar = 'Middle'; // Middle function scope
    
    function innerFunction() {
      let innerVar = 'Inner'; // Inner function scope
      
      // Inner function bisa akses SEMUA variabel di atasnya
      console.log(innerVar);  // "Inner"
      console.log(middleVar); // "Middle"
      console.log(outerVar);  // "Outer"
      console.log(globalVar); // "Global"
    }
    
    innerFunction();
  }
  
  middleFunction();
}

outerFunction();
```

### ğŸ“Š Aturan Lexical Scope:

**Inner Function bisa akses:**
- âœ… Variabel sendiri
- âœ… Outer function variables
- âœ… Global variables
- âŒ Sibling function variables

**Outer Function bisa akses:**
- âœ… Variabel sendiri
- âœ… Global variables
- âŒ Inner function variables
- âŒ Sibling function variables

**Global Scope bisa akses:**
- âœ… Variabel global saja
- âŒ Function variables (apapun)

### âš ï¸ Contoh Scope Chain:

```javascript
function init2() {
  let nama = 'ahmad';
  let umur = 31;

  function tampilNama2() {
    console.log(nama); // Akses ke parent scope
    console.log(umur); // Akses ke parent scope
  }

  // Gunakan console.dir() untuk melihat scope chain
  console.dir(tampilNama2);
  
  tampilNama2();
}

init2();
```

### ğŸ”¬ Analisis Scope dengan console.dir():

Ketika kita menggunakan `console.dir(tampilNama2)`, kita akan melihat:

```
[[Scopes]]: Array(2)
  0: Closure (init2) {nama: 'ahmad', umur: 31}
  1: Global {window: Window, self: Window, ...}
```

**Penjelasan:**
- **Closure (init2)** - Variabel dari outer function
- **Global** - Variabel global yang tersedia

### ğŸ¯ Kesimpulan Lexical Scope:

- **Lexical** = berdasarkan tempat dimana variabel dideklarasikan
- **Scope** = area dimana variabel bisa diakses
- Inner function selalu bisa akses outer function variables
- Outer function TIDAK bisa akses inner function variables

---

## ğŸ”§ Cara Kerja Closure

### 1ï¸âƒ£ **Closure dengan console.dir()**

```javascript
function init2() {
  let nama = 'ahmad';
  let umur = 31;

  function tampilNama2() {
    console.log(nama);
    console.log(umur);
  }

  console.dir(tampilNama2); // Lihat [[Scopes]]
}

init2();
```

> ğŸ’¡ **Penjelasan [[Scopes]]:**
> ```
> Scopes[2]
> 0: Closure (init2) {nama: 'ahmad', umur: 31}
> 1: Global {window: Window, self: Window, ...}
> ```

### 2ï¸âƒ£ **Mengembalikan Function**

```javascript
function init3() {
  function tampilNama3(nama) {
    console.log(nama);
  }

  return tampilNama3; // Return function tanpa eksekusi
}

let panggilNama = init3();
panggilNama('budi'); // Output: "budi"
```

### 3ï¸âƒ£ **Versi Ringkas - Anonymous Function**

```javascript
function init4() {
  return function (nama) {
    console.log(nama);
  };
}

let panggilNama2 = init4();
panggilNama2('candra'); // Output: "candra"
panggilNama2('edi');    // Output: "edi"
```

---

## ğŸ­ Kegunaan Closure

### 1ï¸âƒ£ **Function Factory**

Function factory adalah function yang menghasilkan function lain dengan konfigurasi tertentu:

```javascript
function ucapkanSalam(waktu) {
  return function (nama) {
    console.log(`Halo, ${nama}, selamat ${waktu}, semoga harimu menyenangkan!`);
  };
}

let selamatPagi = ucapkanSalam('Pagi');
let selamatSiang = ucapkanSalam('Siang');
let selamatMalam = ucapkanSalam('Malam');

selamatPagi('ahmad');  // Output: "Halo, ahmad, selamat Pagi, semoga harimu menyenangkan!"
selamatSiang('budi');  // Output: "Halo, budi, selamat Siang, semoga harimu menyenangkan!"
selamatMalam('candra'); // Output: "Halo, candra, selamat Malam, semoga harimu menyenangkan!"
```

### 2ï¸âƒ£ **Private Method (Encapsulation)**

Closure memungkinkan kita membuat variabel yang "tersembunyi" dari luar:

#### âŒ **Masalah tanpa Closure:**

```javascript
let counter = 0;

let add = function () {
  return ++counter;
};

counter = 10; // Variabel bisa diubah dari luar!

console.log(add()); // Output: 11
console.log(add()); // Output: 12
console.log(add()); // Output: 13
```

> âš ï¸ **Masalah:** Variabel `counter` bisa diubah dari luar, sehingga hasil tidak terprediksi.

#### âœ… **Solusi dengan Closure:**

```javascript
let tambah = function () {
  let number = 0; // Variabel private

  return function () {
    return ++number;
  };
};

let tambahAngka = tambah();
console.log(tambahAngka()); // Output: 1
console.log(tambahAngka()); // Output: 2
console.log(tambahAngka()); // Output: 3
```

### 3ï¸âƒ£ **IIFE (Immediately Invoked Function Expression)**

Versi yang lebih ringkas menggunakan IIFE:

```javascript
let tambah2 = (function () {
  let number = 0;

  return function () {
    return ++number;
  };
})(); // Langsung dijalankan

console.log(tambah2()); // Output: 1
console.log(tambah2()); // Output: 2
console.log(tambah2()); // Output: 3
```

---

## ğŸ“Š Perbandingan Metode

| Metode | Keamanan | Kemudahan | Penggunaan |
|--------|----------|-----------|------------|
| **Global Variable** | âŒ Tidak Aman | âœ… Mudah | Counter sederhana |
| **Function dengan Closure** | âœ… Aman | âš ï¸ Sedang | Private data |
| **IIFE** | âœ… Aman | âš ï¸ Sedang | One-time setup |

---

## ğŸ¯ Kesimpulan

Closure adalah konsep yang powerful dalam JavaScript yang memungkinkan:

1. **ğŸ­ Function Factory** - Membuat function dengan konfigurasi berbeda
2. **ğŸ”’ Private Method** - Menyembunyikan data dari akses luar
3. **ğŸ›¡ï¸ Data Encapsulation** - Melindungi variabel dari perubahan tidak diinginkan

### ğŸ’¡ **Tips untuk Pemula:**
- Mulai dengan contoh sederhana lexical scope
- Pahami perbedaan antara memanggil function vs mengembalikan function
- Gunakan `console.dir()` untuk melihat scope chain
- Praktek dengan membuat function factory sederhana

---

## ğŸš€ Langkah Selanjutnya

Setelah memahami closure, Anda bisa mempelajari:
- Module Pattern
- Callback Functions
- Promises dan Async/Await
- Event Handling dengan Closure

---

> ğŸ“š **Catatan:** Closure adalah fondasi untuk memahami konsep JavaScript yang lebih advanced. Luangkan waktu untuk memahami dan mempraktekkan setiap contoh di atas!
